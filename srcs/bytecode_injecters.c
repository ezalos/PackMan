#include "head.h"

#define ENDIAN(x) (((Elf64_Ehdr *)x->content)->e_ident[EI_DATA] != ELFDATA2LSB)
#define IS64(x) (((Elf64_Ehdr *)x->content)->e_ident[EI_CLASS] != ELFCLASS64)


uint8_t test_endian(void)
{
    int     test_var = 1;
    uint8_t *test_endian = (uint8_t*)&test_var;

    return (test_endian[0] == 0);
}

uint8_t is_same_endian(t_packer *packer)
{
    return (test_endian() == ENDIAN(packer));
}


int     can_i_inject(t_zone *zone, size_t size)
{

}

// UNSAFE DOES NOT CHECK FOR WRITEABILITY OR SIZE
void    inject_jump(t_packer *packer, uint8_t* dest, int arg1)
{
    uint8_t opcode = 0xe9;
    if (!is_same_endian(packer))
    {
        change_endian(&arg1, sizeof(arg1));
    }
    dest[0] = opcode;
    ft_memcpy(dest + 1, &arg1, sizeof(arg1));
}

#define PAYLOAD_SIZE	0x70
void inject_write(t_packer *packer, uint8_t* vaddr)
{
    uint8_t payload[PAYLOAD_SIZE] = {
		0x57, // push   rdi
		0x56, // push   rsi
		0x52, // push   rdx
		0x50, // push   rax

		0x68, 0x2e, 0x2e, 0x2e, 0x2e, // push   0x2e2e2e2e
		0x48, 0x89, 0xe6,			  // mov    rsi,rsp
		0xbf, 0x01, 0x00, 0x00, 0x00, // mov    edi,0x1
		0xba, 0x04, 0x00, 0x00, 0x00, // mov    edx,0x4
		0xb8, 0x01, 0x00, 0x00, 0x00, // mov    eax,0x1
		0x0f, 0x05,					  // syscall

		0x68, 0x57, 0x4f, 0x4f, 0x44, // push   0x444f4f57
		0x48, 0x89, 0xe6,			  // mov    rsi,rsp
		0xbf, 0x01, 0x00, 0x00, 0x00, // mov    edi,0x1
		0xba, 0x04, 0x00, 0x00, 0x00, // mov    edx,0x4
		0xb8, 0x01, 0x00, 0x00, 0x00, // mov    eax,0x1
		0x0f, 0x05,					  // syscall

		0x68, 0x59, 0x2e, 0x2e, 0x2e, // push   0x2e2e2e59
		0x48, 0x89, 0xe6,			  // mov    rsi,rsp
		0xbf, 0x01, 0x00, 0x00, 0x00, // mov    edi,0x1
		0xba, 0x04, 0x00, 0x00, 0x00, // mov    edx,0x4
		0xb8, 0x01, 0x00, 0x00, 0x00, // mov    eax,0x1
		0x0f, 0x05,					  // syscall

		0x68, 0x2e, 0x0a, 0x00, 0x00, // push   0xa2e
		0x48, 0x89, 0xe6,			  // mov    rsi,rsp
		0xbf, 0x01, 0x00, 0x00, 0x00, // mov    edi,0x1
		0xba, 0x02, 0x00, 0x00, 0x00, // mov    edx,0x2
		0xb8, 0x01, 0x00, 0x00, 0x00, // mov    eax,0x1
		0x0f, 0x05,					  // syscall

		0x58, // pop    rax
		0x58, // pop    rax
		0x58, // pop    rax
		0x58, // pop    rax

		0x58, // pop    rax
		0x5a, // pop    rdx
		0x5e, // pop    rsi
		0x5f  // pop    rdi
	};
}